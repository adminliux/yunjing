/**
 * @description JS类
 * @author QipanLee
 */
var pos = null, // 记录被拖动对象的位置
hoverApp, // 拖动元素时所经过的模块
previewEle, // 拖动插入之前进行的预览元素
isIEEvent, // 是否是基于IE浏览器的事件模型
curDragObj, // 当前拖曳对象
isSelected, // 是否选中模块

isFillUpTip;   // 是否在添加提示信息(“空白模块...”)

//=================================================================================

/**
 * 页面操作类<br>
 * 此类中生成的　class 为 “drags_tip” 的　div 为空白栏目的提示　div,
 *　　　　class 为　 “drags_blank” 的　div 为空白的　div　，用于实现向下入不拖动的功能
 */

/**
 * 调试函数
 */
function debug(msg)
{
	var debug_info = window.debug_info;
	if (debug_info === undefined)
	{
		debug_info = document.createElement('div');
		debug_info.id = 'debug_info';
		debug_info.style.position = 'absolute';
		debug_info.style.left = '500px';
		debug_info.style.top = '500px';
		debug_info.style.color = 'red';
		debug_info.style.fontSize = '20px';
		document.body.appendChild(debug_info);
		window.debug_info = debug_info;
	}
	debug_info.innerHTML = msg;
}

/**
 * 根据Class名来查找对象
 */
function getElementByClassName(className, tagName, node)
{
	tagName = tagName || '*';
	node = node || document;
	var all = node.getElementsByTagName(tagName), reg = new RegExp("(^|\\s)"
			+ className + "(\\s|$)"), res = [], index = 0;
	for ( var i = 0; i < all.length; i++)
	{
		if (reg.test(all[i].className))
		{
			res[index++] = all[i];
		}
	}
	return res;
}

/**
 * 获取对象的起点坐标y
 */
function getPosTop(obj)
{
	var l = obj.offsetTop;
	while (obj = obj.offsetParent)
	{
		l += obj.offsetTop;
	}
	return l;
}

/**
 * 获取对象的起点坐标x
 */
function getPosLeft(obj)
{
	var l = obj.offsetLeft;
	while (obj = obj.offsetParent)
	{
		l += obj.offsetLeft;
	}
	return l;
}

/**
 * 获取对象的坐标
 * 
 * @param _obj
 *            Ｄom对象
 * @returns 封装{x : x, y : y}的对象
 */
function getPos( _obj )
{
	/*
	 * var posx = 0; var posy = 0; if (evt.pageX || evt.pageY) { posx =
	 * evt.pageX; posy = evt.pageY; } else if (evt.clientX || evt.clientY) {
	 * posx = evt.clientX + document.body.scrollLeft +
	 * document.documentElement.scrollLeft; posy = evt.clientY +
	 * document.body.scrollTop + document.documentElement.scrollTop; } return
	 * {x:posx, y:posy};
	 */
    var curleft = _obj.offsetLeft,
        curtop  = _obj.offsetTop;
    while ( _obj = _obj.offsetParent ) 
    { 
        curleft += _obj.offsetLeft;
        curtop  += _obj.offsetTop;
    } 
    return {x:curleft, y:curtop}; 
}

/**
 * 获取相对document的坐标
 * 
 * @param event
 *            事件对象
 * @returns 封装{x : x, y : y}的对象
 */
function getCorInDoc(event)
{
	return {
		x : isIEEvent ? event.clientX
				+ Math.max(document.body.scrollLeft,
						document.documentElement.scrollLeft) : event.pageX,
		y : isIEEvent ? event.clientY
				+ Math.max(document.body.scrollTop,
						document.documentElement.scrollTop) : event.pageY
	}
}


//=================================================================================
/**
 * 公用拖拽方法
 *  
 */
var MyouDrag = function() {
	
	/**
	 * 拖拽对象
	 */
	var target =  null
	,
	
	/**
	 * 发生拖拽时的回调函数
	 */
	moveCallback = null
	,
	/**
	 * 拖拽完成后的回调函数
	 */
	endCallback = null
	,
	/**
	 * 是否是IE的事件类型
	 */
	isIeEvent = false
	,
	/**
	 * 必要的位置信息
	 */
	pos = {
		/** 对象的宽 */
		targetX: null, 
		/** 对象的高 */
		targetY: null,
		/** 对象的鼠标到位置左边框的距离 */
		detalX:  null, 
		/** 对象的鼠标到位置上边框的距离 */
		detalY:  null
	}
	,
	initByMouseDown = function( e, obj, moveCallback, endCallback )
	{
		e = MyouEvent.getE(e);
		this.init(obj, moveCallback, endCallback);
		this.mousedown(e);
	}
	,
	/**
	 * 鼠标按下事件，用来注册一系列的拖拽动作
	 */
	mousedown = function( e )
	{
		isIeEvent = window.event ? true : false; 
		e = MyouEvent.getE(e);
		pos.detalX = e.clientX - target.offsetLeft;
		pos.detalY = e.clientY - target.offsetTop;
		pos.targetX = target.clientWidth;
		pos.targetY = target.clientHeight;
		
		// 捕获鼠标事件
		if (target.setCapture)
		{
			target.setCapture();
			target.onmousemove = mousemove;
			target.onmouseup = mouseup;
			target.onlosecapture = mouseup;
		} else if (document.addEventListener)
		{
			window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
			document.addEventListener('mousemove', mousemove, true);
			document.addEventListener('mouseup', mouseup, true);
		} else
		{
			
			document.onmousemove = mousemove;
			document.onmouseup = mouseup;
		}
		
		// 取消事件的默认行为
		MyouEvent.preventDefault(e);
		// 取消事件的传播
		MyouEvent.stopPropagation(e);
	}
	,
	/**
	 * 鼠标移动事件
	 */
	mousemove = function( e )
	{
		// 兼容浏览器之间的差异性
		e = MyouEvent.getE(e);

		var x = e.clientX - pos.detalX, y = e.clientY - pos.detalY;

		// 重绘对话框的位置
		target.style.left = x + 'px';
		target.style.top = y + 'px';
		
		MyouEvent.preventDefault(e);

		// 取消事件的传播
		MyouEvent.stopPropagation(e);
	}
	,
	/**
	 * 鼠标松开事件 即结束拖拽事件
	 */
	mouseup = function(e)
	{
		e = MyouEvent.getE(e);

		MyouEvent.preventDefault(e);

		if (target.releaseCapture)
		{
			target.releaseCapture();
			target.onmousemove = null;
			target.onmouseup = null;
			target.onmouseout = null;

			// 在测试过程中， 发现firefox也支持setCapture
			MyouEvent.stopPropagation(e);
		} else if (window.captureEvents)
		{
			window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
			document.removeEventListener('mousemove', mousemove, true);
			document.removeEventListener('mouseup', mouseup, true);
			document.removeEventListener('mouseout', mouseup, true);
			e.stopPropagation();
		} else
		{
			document.onmousemove = null;
			document.onmouseup = null;
			document.onmouseout = null;
		}

		// 删除所有的闭包函数
		delete pos, target, moveCallback, endCallback;
		delete init, initByMouseDown, mousedown, mousemove, mouseup;
	};
	
	/**
	 * 初始化方法
	 * 
	 * @param toTarget　所作用的窗口
	 * @param obj　拖拽的区域[可选参数]
	 * 
	 */
	this.bind = function( toTarget, obj, moveCallback, endCallback )
	{
		// 初始化被拖拽对象
		target = toTarget;
		obj    = obj || target;
		// 获取必要的位置信息
		obj.onmousedown = mousedown;
		// 注册移动时的回调函数
		moveCallback = moveCallback;
		// 注册完成拖拽的回调函数
		endCallback  = endCallback;

	};

}

//=================================================================================
/**
 * 事件公用类
 * 
 */
var MyouEvent = {

		/**
		 * 获取事件对象 用于修复浏览器的兼容性
		 */
		getE : function( e )
		{
			return e || window.event;
		}
		,
		/**
		 * 是否是基于ＩＥ的事件类型
		 */
		isIEEvent : function( )
		{
			return window.event == undefined ? false : true;
		}
		,
		/**
		 * 取消事件的默认行为
		 */
		preventDefault : function( e )
		{
			if (this.isIEEvent())
			{
				e.returnValue = false;
			} else if (e.preventDefault)
			{
				e.preventDefault();
			}
		}
		,
		/**
		 * 取消事件的传播
		 */
		stopPropagation : function( e )
		{
			if ( this.isIEEvent() )
			{
				e.cancelBubble = true;
				return false;
			} else if (e.stopPropagation)
			{
				e.stopPropagation();
			}
		}
};

/**
 * 拖动主方法
 */
function drag(event)
{
	/*
	 * MyouDrag.initByMouseDown(event, (event.srcElement ||
	 * event.target).parentNode)
	 */
	
	if (isIEEvent == undefined)
	{
		isIEEvent = (window.event) ? true : false;
	}
	
	event = window.event || event;

	if( curDragObj != null && curDragObj.style.position === 'absolute' ) 
	{
		drag_removeEffect();
		table.reload();
	}
	
	// ============特效初始化中=========================
	// 绑定的实质是父节点
	var target = this.parentNode;
	curDragObj = target;
	
	// 将对象的定位设置为absolute, 并备份高宽
	drag_addEffect();
	
	// ============变量初始化中=========================
	// 获取必要的位置信息
	//pos.detalX = event.clientX - target.offsetLeft, 
	//pos.detalY = event.clientY - target.offsetTop, 
	var scrollSize = getDocScrollSize();
	pos.detalX = event.clientX - parseInt(target.style.left) + scrollSize.x; 
	pos.detalY = event.clientY - parseInt(target.style.top) + scrollSize.y;
	
	pos.targetX = target.clientWidth,
	pos.targetY = target.clientHeight;

	// ============事件初始化中=========================
	// 捕获鼠标事件
	if (target.setCapture)
	{
		target.setCapture();
		target.onmousemove = drag_mousemove;
		target.onmouseup = drag_mouseup;
		target.onlosecapture = drag_mouseup;
	} else if (document.addEventListener)
	{
		window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
		document.addEventListener('mousemove', drag_mousemove, true);
		document.addEventListener('mouseup', drag_mouseup, true);
	} else
	{
		document.onmousemove = drag_mousemove;
		document.onmouseup = drag_mouseup;
	}

	// 取消事件的默认行为
	if (isIEEvent)
	{
		event.returnValue = false;
	} else if (event.preventDefault)
	{
		event.preventDefault();
	}

	// 取消事件的传播
	if (isIEEvent)
	{
		event.cancelBubble = true;
		return false;
	} else if (event.stopPropagation)
	{
		event.stopPropagation();
	}

}

/**
 * 拖动时给鼠标绑定的鼠标移动事件
 */
function drag_mousemove(eve)
{

	//if( curDragObj == null ) {
		//drag_mouseup(eve);
	//	return;
	//}
	
	// 兼容浏览器之间的差异性
	eve = eve || window.event;
	var scrollSize = getDocScrollSize();
	var x = eve.clientX - pos.detalX + scrollSize.x,
	    y = eve.clientY - pos.detalY + scrollSize.y;
	
	// 重绘对话框的位置
	if (x >= 0 && (x + pos.targetX) <= pos.docX)
	{
		curDragObj.style.left = x + 'px';
	}

	curDragObj.style.top = y + 'px';
	
	// 自动滚屏
	drag_autoMove(eve);
	
	// 实现子模块之间的自动插入
	if( table.rows[curDragObj.pos.rowIndex].length == 1 )
	{
		table.fillupTipBox( curDragObj.pos.rowIndex );
	}
	
	// 获取拖动模块时 位于鼠标下面的模块元素
	hoverApp = table.getHoverElement(getCorInDoc(eve).x, getCorInDoc(eve).y,
			curDragObj);

	// 假如获取到啦所在的DOM对象，则自动插入
	if ( hoverApp )
	{
		previewEle.style.display = 'block';
		previewEle.style.width = hoverApp.clientWidth + 'px';
		hoverApp.parentNode.insertBefore(previewEle, hoverApp);
		isSelected = true;
	}

	if (isIEEvent)
	{
		eve.returnValue = false;
	} else if (eve.preventDefault)
	{
		eve.preventDefault();
	}

	// 取消事件的传播
	if (isIEEvent)
	{
		eve.cancelBubble = true;
	} else if (eve.stopPropagation)
	{
		eve.stopPropagation();
	}
	
	pos.docY = getDocSize().y;

}

/**
 * 拖动时给鼠标绑定的鼠标松开事件
 */
function drag_mouseup(eve)
{

	drag_removeEffect();
	
	// 获取事件对象
	eve = eve || window.event;

	// 由于在基于IE的事件里，给curDragObj绑定了两次失去焦点的事件，因为此方法会并发执行两次，
	// 由于执行的速度很快，所以这里还要判断curDragObj是否为空
	if ( curDragObj.releaseCapture )
	{
		//try {
			curDragObj.onmousemove = null;
			curDragObj.onmouseup = null;
			curDragObj.onmouseout = null;
			curDragObj.releaseCapture();
	//	} catch (e) {
			//darg_stopAutoMove();
			//return;
	//	}

		// 在测试过程中， 发现firefox也支持setCapture
		if (isIEEvent)
		{
			eve.cancelBubble = true;
		} else
		{
			eve.stopPropagation();
		}
	} else if (window.captureEvents)
	{
		window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
		document.removeEventListener('mousemove', drag_mousemove, true);
		document.removeEventListener('mouseup', drag_mouseup, true);
		document.removeEventListener('mouseout', drag_mouseup, true);
		eve.stopPropagation();
	} else
	{
		document.onmousemove = null;
		document.onmouseup = null;
		document.onmouseout = null;
	}
	
	// 清除事件的默认行为
	if (isIEEvent)
	{
		eve.returnValue = false;
	} else if (eve.preventDefault)
	{
		eve.preventDefault();
	}

	// 一次拖动事件完成， 清除临时数据
	delete pos;

	// 还原到之前的位置
	if (!isSelected)
	{
		hoverApp = curDragObj;
	}
	
	if ( isSelected ) 
	{
		isSelected = false;
		previewEle.style.display = 'none';
		table.insertBefore( [ curDragObj.pos.rowIndex, curDragObj.pos.cellIndex, 
		                      hoverApp.pos.rowIndex, hoverApp.pos.cellIndex ] );
	}

	
	// 若屏幕还在自动滚动 则停止些操作
	darg_stopAutoMove();
	
}

/**
 * 鼠标移动时，给当前拖动的对象添加移动时的效果
 */
function drag_addEffect() 
{
	if( curDragObj == null )
	{
		return ;
	}
	curDragObj.style.width = curDragObj.clientWidth + 'px';
	curDragObj.style.height = curDragObj.clientHeight + 'px';
	curDragObj.style.top = getPosTop(curDragObj) + 'px';
	curDragObj.style.left = getPosLeft(curDragObj) + 'px';
	curDragObj.style.zIndex = 550;
	curDragObj.style.position = 'absolute';
	$(curDragObj).addClass('drag');
}

/**
 * 鼠标移动结束，将当前拖动对象的临时效果去掉
 */
function drag_removeEffect() 
{
	if( curDragObj == null )
	{
		return ;
	}
	curDragObj.style.width = '100%';
	curDragObj.style.height = '100%';
	curDragObj.style.position = '';
	curDragObj.style.zIndex = '';
	$(curDragObj).removeClass('drag');
}

/**
 * 自动滚动屏幕
 * 
 * @param eve 事件对象
 * @param [scrollSize] 页面滚动条大小, 可选参数
 */
function drag_autoMove( eve,  scrollSize) 
{
	
	// 假如没有参数，则初始化参数
	scrollSize = scrollSize || getDocScrollSize();
	
	// 当前坚着的滚动条向上的高度
	var curY = scrollSize.y, 
	// 是移动还是停止
		isMOve,
	// 所要移动的高
		toMoveHei,
	// 计时
		t = 0;
	
	// 当此时纵坐标 <= 0时，开始自动向上滚屏
	if( eve.clientY <= 0 && curY > 0) 
	{
		if(curDragObj != null) curDragObj.style.visibility = 'hidden';
		if( !window.TIMEOUT_AUTO_MOVE ) 
		{
			
			(function(){
				//curY -= 10;
				//scrollTo(0, curY);
				toMoveHei = curY - 1 * (t * t);
				if( toMoveHei < 0 )
				{
					toMoveHei = 0;
				}
				scrollTo(0, toMoveHei);
				t++;
				window.TIMEOUT_AUTO_MOVE = setTimeout(arguments.callee, 30);
				if( curY < 20 )
				{
					darg_stopAutoMove();
				}
			})();
		}
		return;
	}

	// 当此时纵坐标接近屏幕底部时，开始自动向下滚屏
	else if(  eve.clientY >= pos.screenY )
	{
		if(curDragObj != null) curDragObj.style.visibility = 'hidden';
		var t = 0;
		if( !window.TIMEOUT_AUTO_MOVE ) 
		{
			
			(function(){
				//curY += 10;
				toMoveHei = curY + 1 * (t * t);
				scrollTo(0, toMoveHei);
				if( toMoveHei > pos.docY )
				{
					toMoveHei = pos.docY;
				}
				t++;
				window.TIMEOUT_AUTO_MOVE = setTimeout(arguments.callee, 30);
				if( toMoveHei + pos.targetY > pos.docY )
				{
					darg_stopAutoMove();
				}
			})();
		}
		return;
	}else 
	{
		darg_stopAutoMove();
	}
}

/**
 * 停止滚动屏幕
 * 
 */
function darg_stopAutoMove() {
	
	// 判断全局变量中是否存在滚动的定时器
	if( window.TIMEOUT_AUTO_MOVE )
	{
		// 假如当前拖曳对象不为空
		if(curDragObj != null) 
		{
			// 强制显示，因为屏幕滚动时，会自动地将拖曳对象给隐藏掉
			curDragObj.style.visibility = '';
		}
		// 清除此定时器
		clearTimeout( window.TIMEOUT_AUTO_MOVE );
		// 清除此变量的引用
		window.TIMEOUT_AUTO_MOVE = null;
	}
}

/**
 * 获取指定DOM对象计算后当前的CSS属性值(包含外部ＣＳＳ)
 * 		注意：此方法有兼容性问题，在IE6,Opera等部分浏览器的style与一般浏览器的写法不一至，
 *    举backgroundColor为例,则background-color
 * 
 * @param _obj
 *            Ｄom对象
 * @param _type
 *            style属性值
 * @returns ＣＳＳ属性值的字符串
 */
function getStyle( _obj, _type ) 
{
	if( _obj.currentStyle ) 
	{
		return (_obj.currentStyle[_type]);
	} else if( document.defaultView )
	{
		return (document.defaultView.getComputedStyle(_obj, null).getPropertyValue(_type));
	} else 
	{
		return _obj.style[_type];
	}
}

/**
 * 获取滚动条（隐藏）的高度，即页面向下翻页过程中被隐藏掉的上高度
 * @returns　{x : 0, y: 0}类型的数据
 */
function getDocScrollSize()
{
	var isSupportBody = (document.body != undefined), 
		isSupportEle = (document.documentElement != undefined);
	if( isSupportBody && isSupportEle  ) {
		return {
			x : document.body.scrollLeft || document.documentElement.scrollLeft || 0,
			y : document.body.scrollTop || document.documentElement.scrollTop || 0
		}
	}
	if( isSupportBody )
	{
		return {
			x : document.body.scrollLeft,
			y : document.body.scrollTop
		}
	} else if( isSupportEle ) 
	{
		return {
			x : document.documentElement.scrollLeft,
			y : document.documentElement.scrollTop
		}
	}
	
}

/**
 * 获取当前页面的长和宽
 * 
 * @returns 位置信息{x, y}
 */
function getDocSize()
{
	
	return {
		// x 用下面y的方法 在ＩＥ９下面会将scroll计算进去
		//x: document.body != undefined ? document.body.clientWidth : document.documentElement.clientWidth,
		/*
		x: Math.max(document.documentElement["clientWidth"], 
				document.body["scrollWidth"], 
				document.documentElement["scrollWidth"], 
				document.body["offsetWidth"], 
				document.documentElement["offsetWidth"]),
		*/
		x: document.body != undefined ? document.body.clientWidth : document.documentElement.clientWidth,
		y: Math.max(document.documentElement["clientHeight"], 
				document.body["scrollHeight"], 
				document.documentElement["scrollHeight"], 
				document.body["offsetHeight"], 
				document.documentElement["offsetHeight"])
		};
}

/**
 * 获取页面（窗口）的长和宽
 * 
 * @returns 位置信息{x, y}
 */
function getWinSize()
{
	// the more standards compliant browsers (mozilla/netscape/opera/IE7) use
	// window.innerWidth and window.innerHeight
	 if (typeof window.innerWidth != 'undefined')
	 {
	      return {
	    	  x : window.innerWidth,
	    	  y : window.innerHeight
	      }
	 }
	 
	// IE6 in standards compliant mode (i.e. with a valid doctype as the first
	// line in the document)
	 else if (typeof document.documentElement != 'undefined'
	     && typeof document.documentElement.clientWidth !=
	     'undefined' && document.documentElement.clientWidth != 0)
	 {
	       return {
	    	   x : document.documentElement.clientWidth,
	    	   y : document.documentElement.clientHeight
	       }
	 }
	 
	 // older versions of IE
	 else
	 {
	       return {
	    	   x : document.getElementsByTagName('body')[0].clientWidth,
	    	   y : document.getElementsByTagName('body')[0].clientHeight
	       }
	 }
}

/**
 * 根据指定id获取对应的dom元素
 * @param id　对象的id
 * @param parent 父级对象(只能是窗口中的document对象)，可选参数(默认document)
 * @returns 找到的dom元素
 */
function get(id, parent) 
{
	return (parent || document).getElementById(id);
}


/**
 * 根据指定标签名获取对应的dom元素数组
 * @param tagName　对象的标签名
 * @param parent 父级对象，可选参数(默认document)
 * @returns 找到的dom元素数组
 */
function getByTag(tagName, parent) 
{
	return (parent || document).getElementsByTagName(tagName);
}

/**
 * 更新当前的Ｓtyle标签（包含ＣＳＳ）
 */
function replaceStyleDom(before, now) {
	var style = document.createElement('style');
	style.setAttribute('type', 'text/css');
	if( style.styleSheet ) { // for ie
		style.styleSheet.cssText = now.innerHTML;
	} else {
		style.appendChild( document.createTextNode( now.innerHTML ) );
	}
	before.parentNode.replaceChild( style, before );
}

//=================================================================================
/**
 * 窗口类,　封装了窗口及各对话框组件
 * 
 */
var  MyouWin =
{
	/**
	 * 对话框的 Ｄom 对象
	 */
	obj: null,
	
	/**
	 * 当前对话框的窗口对象, 为 Ｄom 元素，id 为 dialog
	 *  
	 */
	win: null,
	
	/**
	 * model对话框的背景的 Ｄom 对象, 此对象 id 为 modelBack
	 */
	modelObj: null,
	
	/**
	 * Ｍodel窗口及背景的前后显示次序
	 */
	zIndex: 3,

	/** 对话框的宽 */
	width: 0,
	
	/** 对话框的高 */
	height: 0,
	
	/**
	 * 可以多Ｍodel窗口显示，此数组用于记录所有的窗口
	 */
	his: [],
	
	/**
	 * 添加按钮时使用
	 */
	_buttons: [],
	
	/**
	 * 对象初始化方法
	 * 
	 * @param _argus[
	 * 				 msg,    		显示的信息, 可显示ＨＴＭＬ
	 *               tiltle,		标题，空值直接隐藏此ＤＩＶ
	 *               width,			宽
	 *               height, 		高
	 *               isMode, 		是否模态窗口（布尔类型）
	 *               hideOkButton,  隐藏按钮区域
	 *               showIcon, 		是否显示图标（布尔类型）
	 *               icon, 			图标路径
	 *               autoClose		自动关闭(number类型，多少秒后自动关闭)
	 *               enterKey		是否使用回车键关闭窗口(boolean类型，模态窗口有效，默认为true)
	 *               s_animate      显示窗口显示动画效果(boolean类型，默认：true)
	 *               c_animate      关闭窗口显示动画效果(boolean类型，默认：false)
	 *               ]
	 */
	init: function( _argus )
	{
		
		/* 初始化参数值  */
		// 初始化宽，默认２５０像素
		_argus['width'] = _argus['width'] || 250;
		// 初始化高，默认１４０像素
		_argus['height'] = _argus['height'] || 140;
		
		/* 初始化DOM */
		// 初始化当前对话框的Ｄom对象
		var dialogDom = document.createElement('div');
		// 设置对话框的基本样式
		dialogDom.className = 'dialog';
		/*
		dialogDom.innerHTML 
					= '\
					  <div class="dialog_box">\
					    <div id="dialog_title" class="dialog_title"></div>\
					    <div id="dialog_content" class="dialog_content"></div>\
						<div id="dialog_buttons" class="dialog_buttons"></div>\
					  </div>';
		*/
		
		// 创建对话框的内容ＤＩＶ
		var div_dialog_box     = document.createElement('div'),
		// 创建对话框正文区域的ＤＩＶ
			div_dialog_content = document.createElement('div'),
		// 高
			container_height = _argus['height'];
		
		//　设置基本样式
		div_dialog_box.className     = 'dialog_box';
		div_dialog_content.className = 'dialog_content';
		
		// 正文 的  div 为 div_dialog_box 的子 ＤＩＶ
		div_dialog_box.appendChild(div_dialog_content);
		// div_dialog_box　为对话框的基本ＤＩＶ
		dialogDom.appendChild(div_dialog_box);
			
		// 将此对话框添加到页面中
		document.body.appendChild(dialogDom);
		
		// 将此对象保存在此对话框的对象中缓存起来
		// 新窗口将处于此窗口对象的焦点
		this.win = dialogDom;
		// 显示区域的ＤＩＶ
		this.obj = div_dialog_content;
		
		// 创建一个对象用来保存显示按钮的ＤＩＶ
		var div_dialog_buttons;
		// 假如显示确定按钮
		//if( _argus['hideOkButton'] != true)
		if( this._buttons.length > 0)
		{
			// 创建一个显示按钮的ＤＩＶ
			div_dialog_buttons = document.createElement('div');
			// 设置显示的样式
			div_dialog_buttons.className = 'dialog_buttons';
			// 将此ＤＩＶ应用到父节点中
			div_dialog_box.appendChild(div_dialog_buttons);
			
			// 创建一个新按钮对象（此对象用作一个模板，方便下面创建新的按钮）
			var newTmpl = document.createElement('button'), newButton;
			//newButton.appendChild( document.createTextNode('') );
			for(var i = 0; i < this._buttons.length; i++) {
				
				newButton = newTmpl.cloneNode(true);
				// 设置按钮的文字显示
				newButton.innerHTML = this._buttons[i][0];
				// 是否为函数，若是函数则绑定指定的事件
				if( (typeof this._buttons[i][1]).toLowerCase() === 'function' ) 
				{
					// 是否禁用了回车键自动关闭
					//if( _argus['enterKey'] == false ) 
					//{
					//	this.win.enterKey = false;
					//}
					// 绑定指定的事件
					newButton.onclick = this._buttons[i][1];
				} else 
				{
					// 给默认的确定按钮绑定事件
					newButton.onclick = function(){MyouWin.close();};
				}
				// 将按钮显示到窗口中
				div_dialog_buttons.appendChild( newButton );
			}
			
			container_height -= div_dialog_buttons.clientHeight;
			// 此对象为一次性的数组，删除对象释放内存
			this._buttons = [];
			newButton = null;
			delete newButton;
			
		}
		
		// 设置对话框的层叠次序
		this.win.style.zIndex = this.zIndex;
		
		// 之所以加２是方便多个模态窗口时，背景层叠的切换
		this.zIndex += 2;
		
		// 判断是否作为模态窗口显示
		if( _argus['isModel'] )
		{
			this.createModel();
		}
		// 是否显示标题
		if( !_argus['title'] ) 
		{
			// 鼠标样式为显示可以移动
			this.win.style.cursor = 'move';
			if( div_dialog_buttons != undefined ) 
			{
				// 若没有标题　直接使用正文的背景色
				div_dialog_buttons.style.background = 'ivory';
			}
			
			// 绑定拖拽事件
			new MyouDrag().bind(this.win);
		} 
		else 
		{
			// 创建对话框标题区域的ＤＩＶ
			var div_dialog_title = document.createElement('div');
			// 标题 的  div 为 div_dialog_box 的子 ＤＩＶ
			div_dialog_title.className   = 'dialog_title';
			// 将此内容向右移动６个空格对齐
			div_dialog_title.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' + _argus['title'];
			// 将可拖拽象区域的鼠标样式为 move
			div_dialog_title.style.cursor = 'move';
			// 将标题放入对话框中
			div_dialog_box.insertBefore(div_dialog_title, div_dialog_content);
			// 更新高
			container_height -= div_dialog_title.clientHeight;
			// 绑定拖拽事件
			new MyouDrag().bind(this.win, div_dialog_title);
		}
		
		// 是否启用指定时间自动关闭窗口
		this.autoClose( _argus['autoClose'] );
		
		// 绑定动画效果
		if( _argus['s_animate'] == false ) 
		{
			this.win.s_animate = false;
		}
		if( _argus['c_animate'] == false ) 
		{
			this.win.c_animate = false;
		}
		
		this.win.enterKey = _argus['enterKey'] || false;
		
		// 检测是否绑定了鼠标回车事件
		if( window.IS_BLIND_KEYDOWN == undefined )
		{
			//window.IS_BLIND_KEYDOWN = true;
			var curKeyDownHandler = document.onkeydown;
			// 绑定回车事件
			document.onkeydown = function( eve ) {
					
				if( MyouWin.win == null || MyouWin.win.enterKey == false )
				{
					return;
				}
				
				// 修复浏览器事件的差异性
				eve =  MyouEvent.getE( eve );
				// 回车键的　KeyCode　为１３，判断是否为回车键
				if( eve && eve.keyCode == 13 )
				{
					// 直接关闭对话框
					MyouWin.close();
					MyouEvent.preventDefault( eve );
					MyouEvent.stopPropagation( eve );
					return;
				}
				
				// 假如当前已绑定了键盘事件，则执行
				if( curKeyDownHandler != null)
				{
					curKeyDownHandler();
				}	
			}
		}
		
		// 初始化对话框的宽
		this.width = _argus['width'];
		// 初始化对话框的高
		this.height = _argus['height'];
		// 初始化对话框显示部分的高
		this.obj.style.height = container_height + 'px';
		// 初始化对话框的宽
		this.win.style.width = this.width + 'px';
		// 初始化对话框的高
		this.win.style.height = this.height + 'px';
		
	},
	
	createModel: function()
	{
		// 系统中只有一个背景，　判断此页面是否含有背景的缓存
		if( !this.modelObj ) {
			// 没有背景，创建一个Ｄiv用来存放背景
			var back = document.createElement('div');
			// 设置　id　为　modelBack
			back.id = 'modelBack';
			// 显示的样式名称
			back.className = 'modelBack';
			// 添加到页面中
			document.body.appendChild(back);
			// 在此对象中缓存此对象的引用
			this.modelObj = back;
			this.modelObj.onclick = function()
			{
				
				// 如果出现了bug
				if( MyouWin.his.length < 1 )
				{
					this.style.display = 'none';
				}
				// 当窗口失去焦点时，抖动窗口提醒用户
				var win = MyouWin.win;
				if( !win && !window.DIALOG_SHAKING )
				{
					return;
				}
				var title = getByTag('div', win)[1];
				if( !title || title.className != 'dialog_title')
				{
					return;
				}
				var index = 0, 
				 	colors = ['ivory', '#bcc9db', '819bb4', 'bcc9db'], 
				 	cursor = 3
				 	curBack = getStyle(title, 'background-color') || getStyle(title, 'backgroundColor') || '';
					window.DIALOG_SHAKING  = true;
				var curTimeout = setTimeout(function()
				{
					
					title.style.background = colors[cursor];
					if( (cursor++) > (colors.length - 2) )
					{
						cursor = 0;
						title.style.background = curBack;
						curTimeout = setTimeout(arguments.callee, 40);
						return;
					}
					
					if( (index++) > 25) 
					{
						title.style.background = curBack;
						index = null;
						title = null; 
						cursor = null;
						colors = null;
						curBack = null;
						delete title, colors, cursor, index;
						clearTimeout( curTimeout );
						curTimeout = null;
						window.DIALOG_SHAKING  = undefined;
						return;
					} else 
					{
						curTimeout = setTimeout(arguments.callee, 20);
					}
				}, 20);	
						
			}
				
		}
		/* 初始化背景的大小及相关属性 */
		// 获取当前页面的高和宽
		var docSize = getDocSize();
		// 初始化背景宽，平铺到当前页面的大小
		this.modelObj.style.width = docSize.x + 'px';
		// 初始化背景高，平铺到当前页面的大小
		this.modelObj.style.height = docSize.y + 'px';
		// 设置背景可见
		this.modelObj.style.display = '';
		// 设置背景的层叠次序，为对话框之下
		this.modelObj.style.zIndex = (this.win.style.zIndex - 1) || 3;
		// 记录当前模态窗口
		this.his.push( this.win );
	},
	
	/**
	 * 居中
	 * 
	 * @param _obj 对话框信息
	 */
	center: function()
	{
		// 获取当前浏览器的文档显示窗口大小
		var winSize = getWinSize();
		// 设置为宽度为水平对齐
		this.win.style.left = (winSize.x - this.width)/2 + 'px';
		// 设置为宽度为当前窗口区域垂直对齐
		this.win.style.top = getDocScrollSize().y + (winSize.y - this.height)/2 + 'px';
	},
	
	createWin: function( _argus ) {
		
		_argus = _argus || [];
		_argus['isModel'] = true;
		_argus['msg'] =  _argus['msg'] || '';
		this.init( _argus );
		/* 图标设置，　假如设置不显示刚默认 */
		// 判断是否显示图标
		if( _argus['showIcon'] == false ||  _argus['icon'] == undefined )
		{
			// 不显示图标，　直接将其设为空字符
			_argus['icon'] = '';
		}
		// 显示内容
		this.obj.innerHTML = '<p style="width:100%; text-align: center;">' + _argus['icon'] + _argus['msg'] + '</p>';
		
		// 显示
		this.show();
		// 居中
		this.center();
	}
	,
	/**
	 * 添加按钮
	 * @param _text [string(两个参数时)、或boolean(一个参数时)]
	 * @param _funs[可选参数, 可以为function, boolean]
	 */
	addButton: function( _text, _funs) {
		
		if( _funs == undefined ) 
		{
			switch( (typeof _text).toLowerCase )
			{
				case 'boolean': 
					// 一个参数的布尔，用于绑定回车事件
					_funs = _text;
					// 默认按钮的文字
					_text = '确定'; 
					break;
				case 'undefined': 
					_funs = true;
					break;
				default:
					break;
			};
		}
		
		// 进行添加按钮
		this._buttons.push( [_text, _funs] );
		// 返回当前对象，以方便于多次添加
		return this;
	},
	
	/**
	 * alert对话框
	 */
	alert: function( _argus )
	{

		/* 若只有一个string的参数，直接用于显示 */
		// 判断所传过来的参数是否是“string”的数据类型
		if( (typeof _argus) === 'string')
		{
			// 参数为string，就直接将些当作msg使用
			var msg = _argus;
			// 初始化参数对象
			_argus = [];
			// 设置
			_argus['msg'] = msg;
		}
		// 初始化参数
		_argus = _argus || [];
		// 绑定回车事件，按回车自动关闭窗口
		_argus['title'] = _argus['title'] || "提示";
		// 采用模态窗口进行显示
		_argus['isModel'] = _argus['isModel'] || true;
		// 绑定回车事件，按回车自动关闭窗口
		_argus['enterKey'] = _argus['isModel'] || true;
		// 添加确定按钮
		this.addButton('确定');
		// 初始化并生成窗口
		this.init( _argus );
		// 设置显示图标
		_argus['icon'] = _argus['icon'] || '<img src="images/dialog/alert.gif" />';
		// 设置显示的文字内容
		this.obj.innerHTML = '<p style="width:100%; text-align: center; margin-top:25px;">' + 
									_argus['icon'] + _argus['msg'] + '</p>';
		
		// 居中窗口
		this.center();
		// 显示窗口
		this.show();
		
	},
	
	/**
	 * 确认对话框
	 * @params _argus 1. 采用上面的{}对象形式
	 * 
	 * 				  2. 传统的传参方式，此时可以传三个参数，第一个参数是必选，后面两个可选
	 *                      (msg[, okHandler][, cancelHandler])
	 * @return 点击 “ＹＥＳ” 返回 true, 否则返回 false
	 */
	confirm: function( _argus ) {
		
		// 假如第一个参数为string说明采用非对象的形式进行传参 
		if( (typeof _argus).toLowerCase() === 'string') 
		{
			var str = _argus;
			_argus = [];
			_argus['msg'] = str;
			if( (typeof arguments[1]).toLowerCase() === 'function' )
			{
				_argus['ok'] = arguments[1];
			}
			if( (typeof arguments[2]).toLowerCase() === 'function' )
			{
				_argus['cancel'] = argusments[1];
			}
		}
		// 若无参数，则创建一个空数组
		_argus = _argus || [];
		// 取消回车事件
		_argus['enterKey'] = false;
		// 初始化图标
		_argus['icon'] = _argus['icon'] || '<img src="images/dialog/confirm.gif" />';
		// 获取当前ok的回调事件的引用
		var okCallBack = _argus['ok'];
		// 开始添加窗口，并进行显示
		this.addButton('确定', 
					// 绑定ＯＫ按钮的处理事件
					function() 
					{ 
						
						// 先关闭窗口
						MyouWin.close();
						
						// 假如绑定了ＯＫ的回调函数，则执行
						if( (typeof okCallBack).toLowerCase() === 'function' )
						{
							okCallBack(); 
						}
						// 返回false，阻止事件进一步的传播
						return false;
					})
		    .addButton('取消', _argus['cancel'] || 
		    		function()
		    		{
						// 执行默认的Cancel事件,关闭当前窗口
		    			MyouWin.close();
						// 返回false，阻止事件进一步的传播
		    			return false;
		    		})
		    .createWin({
				msg : '<div style="width:90%; text-align: center;">' 
												+ _argus['icon'] + _argus['msg'] + '</div>',
				width: _argus['width'] || 250,
				height: _argus['height'] || 150,
				title: _argus['title'] || '注意喽'
			});
	},
	
	/**
	 * 提示窗口，　此窗口没有边框
	 */
	tip : function( msg )
	{
		var _argus = [];
		_argus['msg'] = msg || '';
		_argus['isModel'] = true;
		this.addButton('确定', true);
		this.init( _argus );
		_argus['icon'] = _argus['icon'] || '<img src="images/dialog/alert.gif" />';
		this.obj.innerHTML = '<p style="width:100%; text-align: center; margin-top:25px;">' + _argus['icon'] + _argus['msg'] + '</p>';
		
		// 显示
		this.show();
		// 居中
		this.center();
		
	},
	
	/**
	 * 显示对话框
	 */
	show: function()
	{
		// 假如是模态窗口，则要显示背景
		if( this.modelObj != null )
		{
			this.modelObj.style.display = '';
		}
		if( this.win.style != null )
		{
			if( this.win != null && this.win.s_animate != false ) {
				$(this.win).show(1, 0, 80);
			} else {
				this.win.style.display = '';
			}
		}
	},
	
	/**
	 * 隐藏对话框
	 */
	hide: function()
	{
		// 假如是模态窗口，则要隐藏背景
		if( this.his.length < 1 || 
			(this.his.length === 1 && this.his[ this.his.length -1] == this.win ) )
		{
			this.modelObj.style.display = 'none';
			this.zIndex = 3;
		}
		// 是否显示动画效果
		if( this.win != null && this.win.c_animate != false ) {
			$(this.win).hide(3, 100, 80);
		} else {
			this.win.style.display = 'none';
		}
	},
	
	/**
	 * 关闭窗口
	 */
	close: function()
	{
		var his_len = this.his.length;
		// 获取当前所要关闭的窗口对象
		var lastWin = this.his[ his_len - 1];
		// 若当前对象不存在，则退出
		if( !lastWin )
		{
			// 当前对象不存在，退出函数
			return;
		}
		
		// 激活最新的模态窗口
		//this.win = this.his[ his_len - 1];
		// 更新最新的模态窗口的背景
		this.modelObj.style.zIndex = lastWin.style.zIndex - 3;
		this.zIndex -= 2;
		/*
		if( his_len > 2)
		{
			this.modelObj.style.zIndex = this.his[his_len - 2].style.zIndex - 1;
		} else 
		{
			this.modelObj.style.zIndex = 0;		
		}
		*/
		// 先隐藏窗口
		this.hide();
		// 更新此对象的数组数据
		this.his.pop();
		
		// 设置定时器，以延迟清除此DOM对象
		var curTimeout = setTimeout(function() {
			// 清除此窗口的DOM对象
			document.body.removeChild(lastWin);
			MyouWin._updateWin();
			// 清除此定时器
			clearTimeout( curTimeout );
			// 清空当前定时器
			curTimeout = null;
			// 清空闭包内的对象
			lastWin = null;
			// 清空当前定时器的指针
			delete curTimeout;
		}, 2000);
		
	}
	,
	/**
	 * 自动关闭
	 * @param 秒数（number）
	 */
	autoClose: function( seconds )
	{
		// 假如参数不合法，　不使用自动退出
		if( !seconds || ( typeof seconds ) != 'number' )
		{
			// 退出此方法
			return;
		}
		// 设置定时器，保证程序在指定时间后退出
		var curTimeout = setTimeout(function(){
			// 调用退出的方法
			MyouWin.close();
			// 清除当前的定时器
			curTimeout = null;
			// 删除当前定时器的指针
			delete curTimeout;
			// 时间单位为毫秒，所以乘以１０００
		}, seconds * 1000);
	}
	,
	_updateWin: function() {
		// 激活最新的模态窗口
		this.win = this.his[ this.his.length - 1];
		/*
		if(this.win.style.zIndex - this.modelObj.style.zIndex < 0)
		{
			this.modelObj.style.zIndex = Math.max(this.win.style.zIndex - 3, 0);
		}
		*/
	}
};

//=================================================================================
/**
 * 加载类
 */
var load = {
		
	/**
	 * 当前的iframe的Ｄom对象
	 */
	iframe : null,
	
	/**
	 * 当前的iframe的window对象
	 */
	iframeWin : null,
	
	/**
	 * 初始化函数，初始化默认的iframe对象
	 */
	init : function( src )
	{
		var LOAD_HTML_IFRAME = this.iframeFactory( 'LOAD_HTML_IFRAME' );
		// LOAD_HTML_IFRAME.src = src;
		this.iframe = LOAD_HTML_IFRAME;
		this.iframeWin = this.getIframeWin( 'LOAD_HTML_IFRAME' );
	},
	
	/**
	 * 根据指定的id来获取或生成iframe对象，保证唯一
	 */
	iframeFactory : function( id )
	{
		var obj = document.getElementById( id );
		if( obj )
		{
			return obj;	
		}
		obj = document.createElement('iframe');
		obj.id = id;
		obj.className = 'empty';
		document.body.appendChild( obj );
		return obj;
	},
	
	/**
	 * 获取iframe的window对象
	 */
	getIframeWin : function( id )
	{
		// 若直接以id关联frames集合的浏览器
		if( window.frames[id] )
		{
			// 直接返回当前id的iframe
			return window.frames[id];
		}
		
		// 获取所有Ｉframe的集合
		var allIfr = document.getElementsByTagName('iframe');
		// 手动循环查找指定id的iframe
		for(var i = 0; i < allIfr.length; i++)
		{
			// 假如找到直接退出循环
			if( allIfr[i] && allIfr[i].id === id )
			{
				// 退出循环
				break;
			}
		}
		// 直接返回查找到的iframe没有找到返回undefined
		// 因为在ECMAScript语言中,for循环中定义的变量，
		// 与在外面定义一样，可以被访问
		return window.frames[i];
		
	},
	
	/**
	 * 加载HTML页面
	 * @param src 页面路径
	 * @param callback 回调函数
	 * @param onerror  加载失败时的回调函数
	 */
	loadHTML : function(src, callback, onerror)
	{
		// 初始化
		this.init( src );
		// 获取当前对象的引用
		var ifrWinBack = this.iframeWin, ifrBack = this.iframe, isLoad = false; 
		// 绑定页面加载完成时的事件
		this.iframe. onreadystatechange = this.iframe.onload = function()
		{
			// 防止重复调用此方法
			if( isLoad == true ) 
			{
				return;
			}
			// 防止document拒绝访问
			try{
				if( ifrWinBack.document ) 
				{
				}
			} catch( e ) 
			{
				// 假如有回调函数，则执行
				if( onerror ) onerror();
				// 防止重复执行
				isLoad = true;
				// 清除页面加载完成的函数
				ifrBack.onload = null;
				return;
			}
			if( ifrWinBack.document.readyState=="complete" ) 
			{
				// 防止重复执行
				isLoad = true;
				ifrBack.onload = null;
				// 执行回调函数
				callback( ifrWinBack.document );
			}
		};
		// 更新当前iframe的地址
		this.iframe.src = src;
	}
};

//=================================================================================
/**
 * DOM操作类
 */
var MyouDom = {
	
	/**
	 * 注册当前ＤＯＭ对象
	 */
	regist: function( _obj, _win )
	{
		this._obj = _obj;
		this._win = _win || window;
		return this;
	}
	,
	/**
	 * 获取或设置ＣＳＳ属性值
	 */
	css: function( selector, value )
	{
		if( (typeof value) === 'undefined' )
		{
			return this._obj.style['selector'];
		}
		this._obj.style[selector] = value;
		return this;
	}
	,
	/**
	 * 获取或指定当前ＤＯＭ对象的属性
	 */
	attr: function( selector, value )
	{
		if( (typeof value) === 'undefined' )
		{
			return this._obj.getAttribute(selector);
		}
		this._obj.setAttribute(selector, value);
		return this;
	}
	,
	/**
	 * 插入或获取当前ＤＯＭ的内容
	 */
	html: function( value )
	{
		if( (typeof value) === 'undefined' )
		{
			return this._obj.innerHTML;
		}
		this._obj.innerHTML = value;
		return this;
	}
}